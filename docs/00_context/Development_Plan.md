1: Инициализация окружения. Настройка IDE, Python 3.11, структуры app/.
2: Реализация расширенных контрактов данных. Pydantic-схемы с учетом статусов (partial, failed) и структуры ошибок.
3: Реализация транспорта с защитой (Resilient HTTP). Клиент с Jitter, Backoff, ротацией User-Agent и обработкой 429/403.
Local: “Определён контракт Fetcher (get(url)->str). Реализация по умолчанию для Local MVP: SmartFetcher (sync, requests, headers/UA rotation, минимальная устойчивость). Backoff/Retry как обязательный функционал не требуется на Local MVP.”
Cloud: “Асинхронный resilient транспорт (httpx + tenacity + классификация ошибок) подключается позже через адаптер AsyncResilientFetcherAdapter, не меняя Service Layer.”
4: Парсинг резюме и стратегия тестирования. Парсер с валидацией полноты данных и инструментарием для обновления HTML-фикстур.
5: Локальный Оркестратор (Service Layer). Сборка MVP.
Цель: Объединить Fetcher (1) и Parsers (4) в единый рабочий сервис.
Результат: Скрипт main.py, который принимает поисковый запрос (например, "Python Kyiv"), сам ходит по пагинации, собирает ссылки, скачивает детальные резюме и сохраняет всё в локальный JSON/JSONL файл. CrawlerService использует Fetcher interface (не конкретный класс), текущая реализация — SmartFetcher.
Статус: Пункт 1 твоего воркфлоу выполнен.
6: Proxy-aware Orchestration.
Цель: Обеспечить обход блокировок через управление пулом IP-адресов, не дублируя базовую логику ретраев.
Действия: Выбор и ротация прокси, реализация карантина проблемных IP, политика принудительной смены прокси при 403/ProxyError/ConnectError (в отличие от backoff на одном IP), управление лимитами попыток (на конкретный прокси vs на URL), интеграция связки Executor ↔ ProxyManager ↔ Service Layer.
7: Логика Агента и AI-анализ (Local LLM Integration).
Цель: Подключить "мозги" к собранным данным.
Действия:
Разработка промптов для анализа (фильтрация по стеку, оценка релевантности).
Скрипт, который берет JSON из L5 и прогоняет через API (OpenAI/Anthropic) с учетом лимитов токенов.
Формирование финального отчета по кандидатам.
8: Контейнеризация и Миграция в Облако (Cloud Infrastructure).
Цель: Перенос готового локального решения в Google Cloud Platform.
Действия:
8.1: Dockerfile и локальная сборка контейнера.
8.2: Настройка GCP (Cloud Tasks для очереди парсинга, Firestore для базы данных вместо JSON файлов).
8.3: Деплой в Cloud Run.
Статус: Пункт 3 твоего воркфлоу выполнен.