Целостное описание проекта HR-Agent Pro Execution

1. Название и назначение
Проект: HR-Agent Pro Execution
Назначение:
Облачный сервис для автоматизированного подбора кандидатов, который:
по структурированному запросу рекрутера (через Агента 1 в ChatGPT) формирует поиск резюме на Work.ua;
получает и анализирует резюме «на лету», без долговременного хранения;
сопоставляет резюме с требованиями вакансии;
возвращает рекрутеру только ссылки на резюме Work.ua + оценку соответствия и краткий комментарий о сильных/слабых сторонах кандидата.
Ключевые ограничения:
Сервис не хранит долговременно резюме (ни HTML, ни JSON) — только в рамках обработки одного запроса.
Сервис не сохраняет и не использует ФИО, контактные данные и другие персональные идентификаторы кандидатов.
Проект учебный/личный: без перепродажи данных, без публичной публикации резюме, без коммерческого использования.

2. Высокоуровневая архитектура системы
Система состоит из трёх основных компонентов:
2.1. Агент 1 (в ChatGPT)
Роль: интерфейс для рекрутера.
Функции:
Принимает текстовое описание вакансии и требования к кандидатам.
Уточняет недостающие обязательные и опциональные критерии.
Использует словарь фильтров Work.ua (workua_filters_map.json) для преобразования текстовых требований в структурированный запрос SearchQuery.
Вызывает HTTP-эндпоинты Execution Service.
Реализует алгоритм уточнения поиска при большом количестве результатов:
если total_found > 100, предлагает пользователю сузить критерии по приоритету: обязательные требования → базовые параметры (возраст, опыт, категория);
после согласования формирует новый SearchQuery с уточнёнными фильтрами.
После получения резюме формирует для пользователя список с оценками и комментариями.
2.2. HR-Agent Pro Execution Service
Реализация:
Стек: FastAPI-сервис на Python 3.11.
Деплой: Google Cloud Run (контейнер Docker, порт 8080).
Архитектурный паттерн: Asynchronous Worker Queue.
Основные контракты:
1. POST /search_resumes (Start Job)
ВХОД: SearchQuery (параметры поиска).
ВЫХОД: JobId (JSON: {"job_id": "uuid-string"}).
2. GET /jobs/{job_id} (Check Status)
ВХОД: job_id (path parameter).
ВЫХОД: JobStatus. Структура:
JSON

{
  "status": "pending" | "processing" | "completed" | "failed",
  "processed_count": int,  // Количество уже обработанных резюме
  "total_count": int,      // Общее количество найденных резюме
  "result": SearchResponse | null // null, пока не completed
}


Компоненты системы:
Google Cloud Tasks: Оркестрация очереди. Настройка очереди (max_concurrent_dispatches) регулирует количество параллельных потоков (например, 5-10), чтобы соответствовать лимитам прокси.
Google Firestore: Хранение состояния задач (job_id) и агрегация результатов от разных воркеров.
Воркеры (Cloud Run): Тот же сервис, принимающий задачи от Cloud Tasks. Обрабатывают малые чанки (по 10 резюме) для атомарности и надежности.
2.3. Словарь фильтров Work.ua (workua_filters_map.json)
Назначение: единый конфигурационный JSON-файл, который описывает соответствие между человеческими критериями поиска и параметрами URL Work.ua. Детальные данные для файла предоставляет пользователь дополнительно.
Использование:
Агент 1: для маппинга текста вакансии на параметры SearchQuery.
Execution Service: принимает структурированный SearchQuery от Агента 1, строит по нему URL поискового запроса к Work.ua (используя workua_filters_map.json), выполняет HTTP-запрос, парсит HTML и возвращает SearchResponse.
Статус: структура словаря логически согласована, физически файл app/config/workua_filters_map.json должен быть создан в репозитории.
2.4. Связка Агент 1 ↔ Execution Service
Посредством HTTP-моста (тоже реализуется в Google Cloud, например через Cloud Functions или Cloud Run), который:
принимает от Агента 1 JSON-команды;
вызывает эндпоинты FastAPI-сервиса;
возвращает результаты Агенту 1.

3. Технологический стек
Основная платформа: Google Cloud Все компоненты проекта реализуются средствами Google Cloud:
Деплой Execution Service: Google Cloud Run (используется как API-сервер для приема задач и как Worker для их обработки).
Очереди задач: Google Cloud Tasks (распределение нагрузки, управление повторными попытками/retries и ограничение параллелизма).
База данных: Google Firestore (NoSQL база для хранения состояния Job и временного хранения результатов сбора).
Сетевой слой (Proxy): Использование внешнего провайдера ротируемых резидентных прокси (например, Bright Data / Smartproxy) для обхода блокировок по IP.
Управление кодом: GitHub репозиторий ScienceUA/hr-agent-pro-execution (интеграция с Cloud Build).
Логирование и мониторинг: Google Cloud Logging, Cloud Monitoring.
Секреты и конфигурация: Google Secret Manager (для хранения ключей доступа к прокси и Work.ua credentials).
Среда разработки: Local IDE (Cursor, бесплатная версия). Методология: Код генерируется Агентом в чате, пользователь переносит его в Cursor. Стратегия: Local First — разработка и тестирование модулей (Search, Resume) происходит локально перед контейнеризацией.
Стек Execution Service
Язык: Python 3.11
Web-фреймворк: FastAPI
ASGI-сервер: Uvicorn
HTTP-клиент: httpx
Парсинг HTML: BeautifulSoup4 + lxml
Контейнеризация: Docker (базовый образ python:3.11-slim)
Зависимости (минимальный набор):
fastapi
uvicorn[standard]
httpx
beautifulsoup4
lxml

4. Структура кода в репозитории
Репозиторий: ScienceUA/hr-agent-pro-execution (GitHub, Private)
Запланированная структура (пока не создана физически):
text
hr-agent-pro-execution/
├── app/
│   ├── __init__.py
│   ├── main.py                  # FastAPI-приложение, эндпоинты
│   ├── models.py                # Pydantic-модели контрактов
│   ├── execution/
│   │   ├── __init__.py
│   │   ├── search.py            # Реализация search_resumes
│   │   └── resume.py            # Реализация get_resume
│   └── config/
│       ├── __init__.py
│       └── workua_filters_map.json  # Словарь фильтров Work.ua
├── requirements.txt             # Зависимости Python
├── Dockerfile                   # Образ для Cloud Run
└── README.md                    # Описание сервиса

Текущее фактическое состояние репозитория:
В ветке main присутствуют только:
.gitignore
README.md
Нет папки app/, нет requirements.txt, нет Dockerfile, нет workua_filters_map.json.

5. Контракты данных и конфигурация
Этот раздел разделён на две части:
Контракты данных (Pydantic-модели) — схемы структур, которые описывают формат JSON-объектов, передаваемых между компонентами системы. Реализованы в файле app/models.py.
Конфигурация (workua_filters_map.json) — конкретные значения параметров Work.ua (соответствие человеческих критериев и URL-параметров). Хранятся в файле app/config/workua_filters_map.json.
Важно: Эти две сущности разделены логически и физически:
Контракты определяют как выглядят данные (какие поля, какие типы, обязательны ли).
Конфигурация определяет конкретные значения для построения запросов к Work.ua.

5.1. Контракты данных (Pydantic-модели)
SearchQuery — структура запроса от Агента 1 к Execution Service (эндпоинт /search_resumes):
python
class SearchQuery(BaseModel):
    city_slug: str                  # обязательно: "kyiv", "lviv", "remote" и т.п.
    role_text: str | None = None    # опционально: текст роли для URL (например, "logist")
    page: int = 1
    
    category_ids: list[int] | None = None      # ID категорий Work.ua
    gender_ids: list[int] | None = None        # 86 (мужчины) или 87 (женщины)
    age_from: int | None = None
    age_to: int | None = None
    education_ids: list[int] | None = None     # 66 (неполна вища), 67 (вища), 68 (бакалавр), 69 (магістр)
    experience_ids: list[int] | None = None    # 0 (немає досвіду), 1 (до 1 року), 164-166 (від 2 до 5, понад 5)
    
    language_ids: list[int] | None = None
    language_level_pairs: list[LanguageLevelPair] | None = None
    
    student_only: bool | None = None
    disability_only: bool | None = None
    photo_only: bool | None = None
    
    period_days: int | None = None  # 7, 30 (резюме, обновлённые за последние N дней)

SearchResponse — структура ответа от Execution Service Агенту 1 (эндпоинт /search_resumes):
python
class SearchResponse(BaseModel):
    total_found: int                    # общее количество резюме в выдаче
    resume_urls: list[str]              # список ссылок на все резюме из выдачи (например, ["https://work.ua/resumes/12345/", ...])

ResumeJSON — структура детального резюме (эндпоинт /get_resume):
python
class ResumeJSON(BaseModel):
    resume_url: str
    resume_type: str  # "standard" | "visitka" | "file"
    title: str
    location_main: str
    additional_locations: list[str]
    age: int | None
    
    experience_blocks: list[ExperienceBlock]
    education_blocks: list[EducationBlock]
    skills: list[str]
    languages: list[LanguageSkill]
    additional_courses: list[str]
    work_preferences: WorkPreferences

[Здесь остаются вложенные типы: ExperienceBlock, EducationBlock, LanguageSkill, WorkPreferences — их структура не меняется]

5.2. Конфигурация (workua_filters_map.json)
Файл app/config/workua_filters_map.json — единственный источник истины для соответствий между критериями поиска и параметрами URL Work.ua.
Содержит:
Локации: список городов с их city_slug (например, "kyiv", "lviv"), а также специальные значения ("ukraine", "abroad", "remote").
Категории: ~30 категорий (Accounting, IT, Sales и т.п.) с их category_id и category_slug.
Пол: gender_id (86 = мужчины, 87 = женщины).
Возраст: параметры age_from и age_to (числовые значения).
Опыт работы: experience_id (0 = без опыта, 1 = до 1 года, 164 = 1-2 года, 165 = 2-5 лет, 166 = более 5 лет).
Образование: education_id (66 = неполна вища, 67 = вища, 68 = бакалавр, 69 = магістр).
Языки и уровни: language_id (1 = английский, 3 = немецкий, 41 = польский и т.п.) + language_level_pair (формат "1-22835" — язык+уровень, например, английский вище середнього).
Дополнительные флаги: student, photo, disability, veteran (значения 0/1).
Использование:
Агент 1: Использует этот файл для перевода текстовых требований вакансии (например, «английский не ниже B2», «опыт от 2 лет») в параметры SearchQuery (например, language_level_pairs: [{language_id: 1, level_id: 22835}], experience_ids: [165, 166]).
Execution Service: Использует этот файл для перевода параметров SearchQuery в URL Work.ua (например, ?language=1&language_level=1-22835&experience=165,166).
Важно: Изменения в структуре Work.ua требуют обновления только этого файла, без изменения кода Агента 1 или Execution Service.
Пример структуры workua_filters_map.json:
json
{
  "locations": {
    "ukraine": {"slug": "ukraine", "label": "Вся Україна"},
    "kyiv": {"slug": "kyiv", "label": "Київ"},
    "remote": {"slug": "remote", "label": "Дистанційно"}
  },
  "categories": [
    {"id": 1, "slug": "it-programming", "label": "IT, комп'ютери, інтернет"},
    {"id": 2, "slug": "accounting", "label": "Бухгалтерія, аудит"}
  ],
  "gender": {
    "male": 86,
    "female": 87
  },
  "experience": [
    {"id": 0, "label": "Немає досвіду"},
    {"id": 1, "label": "До 1 року"},
    {"id": 164, "label": "1-2 роки"},
    {"id": 165, "label": "2-5 років"},
    {"id": 166, "label": "Понад 5 років"}
  ],
  "education": [
    {"id": 66, "label": "Неповна вища"},
    {"id": 67, "label": "Вища"},
    {"id": 68, "label": "Бакалавр"},
    {"id": 69, "label": "Магістр"}
  ],
  "languages": {
    "1": "Англійська",
    "3": "Німецька",
    "41": "Польська"
  },
  "language_levels": {
    "1-83": "Початковий (Basic)",
    "1-84": "Середній (Intermediate)",
    "1-22835": "Вище середнього (Upper-Intermediate)",
    "1-85": "Вільне володіння (Advanced/Fluent)"
  }
}

text

***

## 3. Что заменить в описании проекта согласно п.7 (логика поиска и анализа резюме)

### ЗАЧЕМ

Сценарии 1 и 2 в текущем описании содержат ошибки:

- **Сценарий 1:** говорит, что `SearchResponse` возвращает краткую информацию (`SearchResult[]` с заголовками, возрастом, зарплатой), хотя должен возвращать только `total_found` и `resume_urls[]`.
- **Сценарий 2:** говорит, что Агент 1 «выбирает несколько наиболее релевантных», хотя должен загружать **все** резюме из выдачи для анализа по опциональным критериям.

***

### ЧТО ЗАМЕНИТЬ (в разделе "6. Логика работы системы")

**БЫЛО:**


Сценарий 1: Поиск резюме
Рекрутер через Агента 1 задаёт требования к кандидату.
Агент 1 формирует SearchQuery и вызывает POST /search_resumes в Execution Service.
Execution Service:
по SearchQuery и workua_filters_map.json строит URL поискового запроса к Work.ua;
делает HTTP-запрос;
парсит HTML-страницу со списком резюме;
извлекает краткую информацию о каждом резюме (заголовок, локация, возраст, зарплата, флаги);
формирует SearchResponse с total_found и массивом SearchResult[];
возвращает JSON Агенту 1.
Если total_found > 100, Агент 1 предлагает пользователю уточнить критерии и повторяет поиск с новым SearchQuery.
Сценарий 2: Получение детального резюме
Агент 1 выбирает несколько наиболее релевантных resume_url из SearchResult[].
Для каждого URL вызывает POST /get_resume в Execution Service.
Execution Service:
загружает страницу резюме;
определяет тип резюме (обычное, визитка, файл);
парсит блоки: опыт, образование, навыки, языки, дополнительное обучение (без ФИО и контактов);
формирует ResumeJSON;
возвращает JSON Агенту 1.
Агент 1 сопоставляет резюме с вакансией и возвращает пользователю список с оценками и комментариями.
text

***

**СТАЛО:**


Сценарий 1: Поиск резюме
Рекрутер задаёт требования. Через Агента 1 рекрутер описывает требования к кандидату: текст вакансии или критерии подбора (например, «логист с английским B2, опыт от 2 лет, Киев»).
Агент 1 разделяет критерии на обязательные и опциональные:
Обязательные критерии — те, которые можно перевести в фильтры Work.ua (категория, город, образование, опыт работы, языки, возраст, пол). Эти критерии будут автоматически отсеивать резюме через поисковую выдачу Work.ua.
Опциональные критерии — те, которые нельзя проверить через фильтры Work.ua (например, желательные навыки, культурный код компании, глубина опыта в конкретной области). Эти критерии будут проверяться Агентом 1 вручную после загрузки полных данных резюме.
Агент 1 переводит обязательные критерии в параметры SearchQuery. Использует файл workua_filters_map.json для маппинга:
«английский не ниже B2» → language_level_pairs: [{language_id: 1, level_id: 22835}] (вище середнього)
«опыт от 2 лет» → experience_ids: [165, 166] (від 2 до 5 років + понад 5 років)
«Киев» → city_slug: "kyiv"
«категория: логистика» → category_ids: [8] (ID категории "Логістика")
Агент 1 формирует SearchQuery и вызывает POST /search_resumes.
Execution Service обрабатывает запрос:
Берёт параметры из SearchQuery и workua_filters_map.json, строит URL поискового запроса к Work.ua с фильтрами (например, https://www.work.ua/resumes-kyiv-logistics/?language=1&language_level=1-22835&experience=165,166).
Делает HTTP-запрос к Work.ua.
Парсит HTML-страницу со списком резюме.
Извлекает total_found (общее количество резюме, найденных по фильтрам) и resume_urls[] (список ссылок на все резюме из выдачи).
Формирует SearchResponse с этими данными.
Возвращает JSON Агенту 1.
Агент 1 проверяет количество резюме:
Если total_found > 100: сообщает пользователю количество найденных резюме и предлагает сузить критерии (алгоритм уточнения поиска). Предлагает добавить в фильтры:
сначала оставшиеся обязательные требования вакансии (если есть);
если недостаточно — первые три опциональных требования (превратить их в обязательные);
если вакансии нет — уточнить возраст, общий опыт, категорию.
После согласования с пользователем формирует новый SearchQuery с дополнительными фильтрами и повторяет шаг 4.
Если total_found ≤ 100: переходит к сценарию 2 (загрузка и анализ резюме).

Сценарий 2: Загрузка и анализ резюме
Агент 1 получает список всех resume_urls[] от /search_resumes (например, 45 резюме).
Агент 1 для каждого resume_url вызывает POST /get_resume.
Execution Service обрабатывает запрос:
Загружает страницу резюме по URL.
Определяет тип резюме (обычное, визитка, файл).
Парсит блоки:
Опыт работы (должности, периоды, обязанности, достижения).
Образование (учебные заведения, степени, годы).
Навыки (список навыков из резюме).
Языки (язык + уровень).
Дополнительное обучение (курсы, сертификаты).
Пожелания к работе (график, формат работы, зарплатные ожидания).
Не парсит: ФИО, контактные данные (телефон, email), персональные идентификаторы.
Формирует ResumeJSON с этими данными.
Возвращает JSON Агенту 1.
Агент 1 анализирует каждое резюме по опциональным критериям вакансии:
Проверяет наличие желательных навыков (например, «желательно знание 1C», «опыт работы с CRM»).
Оценивает глубину опыта в нужных областях (например, опыт работы в международной логистике, опыт координации команды).
Сопоставляет с культурным кодом компании (если задан): ценности, стиль описания достижений, подача информации.
Присваивает оценку соответствия:
Балльная шкала (например, от 0 до 10).
Или категорию: «отлично подходит», «хорошо подходит», «удовлетворительно», «не подходит».
Агент 1 формирует итоговый список резюме для пользователя:
Ссылка на резюме Work.ua.
Оценка соответствия.
Краткий комментарий (1-2 предложения): «Сильные стороны: опыт координации международных поставок, знание английского на высоком уровне. Слабые стороны: нет опыта работы с таможенным оформлением. Подходит по критериям: образование, возраст, локация, языки.»
Агент 1 возвращает список рекрутеру, отсортированный по убыванию оценки соответствия.

Важные замечания по логике
Обязательные критерии отсеиваются автоматически через фильтры Work.ua (Execution Service не видит резюме, которые им не соответствуют).
Опциональные критерии проверяются Агентом 1 после загрузки полных данных резюме (Execution Service передаёт все резюме из выдачи без предварительной фильтрации по опциональным критериям).
Если после применения обязательных фильтров резюме слишком много (> 100), Агент 1 предлагает добавить часть опциональных критериев в обязательные (превратить их в фильтры), чтобы сузить выдачу до разумного количества.
6. Логика работы системы
Сценарий 1: Поиск резюме
Пользователь через Агента 1 задаёт требования к кандидату в форме вакансии и своих комментариев.
Инициализация задачи: Агент 1 вызывает POST /search_resumes. Execution Service:
Выполняет первичный запрос к Work.ua (через прокси) только для получения общего количества (total_found) и списка ссылок.
Создает запись в Firestore со статусом pending.
Разбивает список ссылок на чанки (по 10 штук).
Создает задачи в очереди Cloud Tasks для каждого чанка.
Мгновенно возвращает Агенту 1 job_id.
Асинхронная обработка (Service Side): • Cloud Tasks вызывает воркеры (Cloud Run) согласно настроенному лимиту параллельности (Rate Limit). • Воркеры обрабатывают свои 10 резюме: загружают страницы через прокси, парсят данные. • Результаты сохраняются в Firestore, обновляется счетчик processed_count. • Если чанк не обработался, Cloud Tasks автоматически повторяет попытку (retry).
Получение результата: Агент 1 периодически опрашивает GET /jobs/{job_id}. • Если processed_count == total_count (или статус completed), Агент 1 получает полный SearchResponse. • Агент 1 выводит пользователю итоговый список.
Если total_found > 100, Агент 1 предлагает пользователю уточнить критерии и повторяет поиск с новым SearchQuery, если пользователь дал дополнительные критерии для уточнения.
Сценарий 2: Получение детального резюме
Агент 1 выбирает несколько наиболее релевантных resume_url из SearchResult[].
Для каждого URL вызывает POST /get_resume в Execution Service.
Execution Service:
загружает страницу резюме;
определяет тип резюме (обычное, визитка, файл);
парсит блоки: опыт, образование, навыки, языки, дополнительное обучение (без ФИО и контактов);
формирует ResumeJSON;
возвращает JSON Агенту 1.
Агент 1 сопоставляет резюме с вакансией и возвращает пользователю список с оценками и комментариями.

7. Принципы работы с Work.ua
Режим доступа:
Используются мягкие задержки между запросами, чтоб не перегружать сервис и не триггерить защиты от массовой нагрузки.
Не строится конкурирующая база, данные получаются, анализируются, в результате пользователь получает только ссылка на отобранные резюме на источнике данных и краткие комментарии о соответствии вакансии.
Юридические и этические аспекты:
Отсутствие постоянного хранения резюме убирает риски по защите данных, так как сервис просто облегчает для пользователей сайта разрешенные действия.
Использование строго для подбора кандидатов под собственные вакансии без публикации и перепродажи.
Основной технический риск — возможная блокировка IP при слишком частых запросах.

8. Текущий статус проекта и следующие шаги
Что согласовано:
Архитектура системы (Агент 1, Execution Service, словарь поисковых критериев Work.ua).
Структура кода и модели данных (SearchQuery, SearchResponse, SearchResult, ResumeJSON).
Содержание для workua_filters_map.json на основе собранных данных о параметрах Work.ua .
Технологический стек с приоритетом на инструменты Google Cloud.
Что создано физически:
GitHub-репозиторий ScienceUA/hr-agent-pro-execution с .gitignore и README.md.
Что НЕ создано (Дорожная карта реализации / Roadmap L1):
Часть I: Создание сервиса сбора данных (Execution Service - Local & Cloud)
L1: Инициализация локального окружения и репозитория. Цель: Настройка Cursor, Python 3.11, Poetry/Pip, создание структуры проекта, базовый main.py.
L1: Реализация контрактов данных и конфигурации (Local). Цель: Перенос Pydantic-моделей (SearchQuery, ResumeJSON) и файла workua_filters_map.json в код.
L1: Реализация логики поиска (Search Engine) на локальной машине. Цель: Локальный эндпоинт /search_resumes. Генерация URL -> Запрос к Work.ua -> Парсинг списка. Без очередей.
L1: Реализация логики парсинга резюме (Resume Engine) на локальной машине. Цель: Локальный эндпоинт /get_resume. Загрузка страницы -> Парсинг деталей -> JSON.
L1: Контейнеризация и подготовка к Google Cloud. Цель: Создание Dockerfile, локальная сборка образа, проверка работы в контейнере.
L1: Настройка инфраструктуры Google Cloud. Цель: Создание проекта GCP, включение API (Run, Tasks, Firestore), создание очереди и базы.
L1: Деплой Execution Service в Cloud Run. Цель: Публикация образа в Artifact Registry, деплой сервиса, интеграция с Cloud Tasks.
Часть II: Интеграция и Анализ (Agent Logic)
L1: Создание HTTP-моста (Integration Layer). Цель: Промежуточный слой для безопасного вызова Cloud Run из ChatGPT.
L1: Настройка логики Агента 1 для поиска. Цель: Промпт для перевода вакансии в JSON-запрос (обязательные фильтры).
L1: Настройка логики Агента 1 для анализа. Цель: Промпт для анализа JSON-резюме по опциональным критериям и Soft Skills.

Этим документом зафиксировано полное видение проекта на текущий момент. Вся дальнейшая реализация происходит пошагово, с использованием инструментов Google Cloud в первую очередь и сторонних инструментов только там, где Google Cloud не предоставляет прямого решения.